[tasks.test]
run = "go test ./..."
description = "Run all tests (unit tests only)"

[tasks.test-unit]
run = "go test ./pkg/... ./internal/..."
description = "Run unit tests"

[tasks.test-integration]
run = "go test ./test/integration/..."
description = "Run integration tests"

[tasks.test-e2e]
run = "go test ./test/e2e/..."
description = "Run end-to-end tests"

[tasks.test-all]
run = "go test ./... && go test ./test/integration/... && go test ./test/e2e/..."
description = "Run all tests: unit, integration, and e2e"

[tasks.test-coverage]
run = "go test -coverprofile=coverage.out ./... && go tool cover -html=coverage.out -o coverage.html"
description = "Run tests with coverage report"

[tasks.test-coverage-integration]
run = "go test -coverprofile=coverage-integration.out ./test/integration/... && go tool cover -html=coverage-integration.out -o coverage-integration.html"
description = "Run integration tests with coverage"

[tasks.test-verbose]
run = "go test -v ./..."
description = "Run all tests with verbose output"

[tasks.build]
run = "go build -o bin/cronmetrics ./cmd/cronmetrics"
description = "Build static binary"

[tasks.dev]
run = "./bin/cronmetrics serve --dev"
description = "Start development server"

[tasks.clean]
run = "rm -rf bin/ dist/ coverage*.out coverage*.html gosec-report.*"
description = "Clean build artifacts, coverage reports, and security reports"

[tasks.lint]
run = "go vet ./... && go fmt ./..."
description = "Run linter and formatter"

[tasks.security]
run = "gosec ./..."
description = "Run gosec security scanner"

[tasks.security-install]
run = "go install github.com/securego/gosec/v2/cmd/gosec@latest"
description = "Install gosec security scanner"

[tasks.security-report]
run = "gosec -fmt json -out gosec-report.json ./... && gosec -fmt junit-xml -out gosec-report.xml ./..."
description = "Run gosec with detailed reports (JSON and XML)"

[tasks.build-all]
run = '''
#!/bin/bash
set -e
echo "Building cronmetrics for all platforms..."

# Build flags for maximum portability
BUILD_FLAGS="-a -installsuffix cgo -ldflags '-w -s -extldflags \"-static\"'"
APP_NAME="cronmetrics"
MAIN_PATH="./cmd/cronmetrics"

# Create dist directory
mkdir -p dist

# Define target platforms
declare -a platforms=(
    "linux/amd64"
    "linux/arm64"
    "linux/386"
    "darwin/amd64"
    "darwin/arm64"
    "windows/amd64"
    "windows/386"
    "freebsd/amd64"
    "openbsd/amd64"
    "netbsd/amd64"
)

# Build for each platform
for platform in "${platforms[@]}"; do
    IFS='/' read -r GOOS GOARCH <<< "$platform"

    # Set output filename
    output_name="${APP_NAME}-${GOOS}-${GOARCH}"
    if [ "$GOOS" = "windows" ]; then
        output_name="${output_name}.exe"
    fi

    echo "Building for $GOOS/$GOARCH..."

    # Build with static linking and no CGO for maximum portability
    env CGO_ENABLED=0 GOOS="$GOOS" GOARCH="$GOARCH" \
        go build -a -installsuffix cgo \
        -ldflags '-w -s -extldflags "-static"' \
        -o "dist/$output_name" "$MAIN_PATH"

    # Verify the binary was created
    if [ -f "dist/$output_name" ]; then
        size=$(du -h "dist/$output_name" | cut -f1)
        echo "✓ Built dist/$output_name ($size)"
    else
        echo "✗ Failed to build dist/$output_name"
        exit 1
    fi
done

echo ""
echo "All builds completed successfully!"
echo "Binaries available in dist/ directory:"
ls -la dist/
'''
description = "Build static binaries for all platforms with maximum portability"

[tasks.build-release]
run = '''
#!/bin/bash
set -e
echo "Building release binaries..."

# Get version from git tag or use development version
if git describe --tags --exact-match HEAD >/dev/null 2>&1; then
    VERSION=$(git describe --tags --exact-match HEAD)
else
    VERSION="dev-$(git rev-parse --short HEAD)"
fi

BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
GIT_COMMIT=$(git rev-parse HEAD)

# Build flags with version information
LDFLAGS="-w -s -extldflags \"-static\" -X main.version=$VERSION -X main.buildTime=$BUILD_TIME -X main.gitCommit=$GIT_COMMIT"
APP_NAME="cronmetrics"
MAIN_PATH="./cmd/cronmetrics"

# Create dist directory
mkdir -p dist

# Define target platforms for release
declare -a platforms=(
    "linux/amd64"
    "linux/arm64"
    "darwin/amd64"
    "darwin/arm64"
    "windows/amd64"
)

# Build for each platform
for platform in "${platforms[@]}"; do
    IFS='/' read -r GOOS GOARCH <<< "$platform"

    # Set output filename with version
    output_name="${APP_NAME}-${VERSION}-${GOOS}-${GOARCH}"
    if [ "$GOOS" = "windows" ]; then
        output_name="${output_name}.exe"
    fi

    echo "Building release for $GOOS/$GOARCH..."

    # Build with version information
    env CGO_ENABLED=0 GOOS="$GOOS" GOARCH="$GOARCH" \
        go build -a -installsuffix cgo \
        -ldflags "$LDFLAGS" \
        -o "dist/$output_name" "$MAIN_PATH"

    # Create compressed archive
    if [ "$GOOS" = "windows" ]; then
        zip -j "dist/${APP_NAME}-${VERSION}-${GOOS}-${GOARCH}.zip" "dist/$output_name"
    else
        tar -czf "dist/${APP_NAME}-${VERSION}-${GOOS}-${GOARCH}.tar.gz" -C dist "$output_name"
    fi

    # Remove uncompressed binary
    rm "dist/$output_name"

    echo "✓ Created release archive for $GOOS/$GOARCH"
done

echo ""
echo "Release build completed!"
echo "Archives available in dist/ directory:"
ls -la dist/
'''
description = "Build release binaries with version info and create compressed archives"

[tasks.ci]
run = "mise run lint && mise run security && mise run test-all && mise run build"
description = "Run CI pipeline: lint, security scan, test, build"

[tasks.ci-full]
run = "mise run lint && mise run security && mise run test-all && mise run build-all"
description = "Run full CI pipeline including multi-platform builds"
